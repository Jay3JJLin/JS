<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型链</title>
</head>

<body>
    <script>
        // 只要是对象 就会有 __proto__ (对象原型),指向原型对象, 形成原型链
        // 只要是原型对象，里面就有constructor
        // 开发中常把prototype称作原型(对象)，把__proto__称作原型链
        // 原型对象prototype也有__proto__(对象原型1),指向上一级的原型对象

        // function Object(){}
        // console.log(Object.prototype);
        console.log(Object.prototype.__proto__);//null

        function Person() { }
        const Jay = new Person();
        console.log(Person.prototype.__proto__ === Object.prototype);//true

        // 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
        console.log(Jay instanceof Person);//true
        console.log(Jay instanceof Object);//true
        console.log(Jay instanceof Array);//false
        console.log([1, 2, 3] instanceof Array);//true
        console.log(Array instanceof Object);//true
        console.log(Person instanceof Object);//true
    </script>
</body>

</html>

<!-- 
基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对
象的链状结构关系称为原型链

原型链-查找规则
① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
② 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）
③ 如果还没有就查找原型对象的原型（Object的原型对象）
④ 依此类推一直找到 Object 为止（null）
⑤ __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线
⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
 -->